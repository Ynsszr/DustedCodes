<!--
    Tags: devops github dotnet-core ci-cd nuget
-->

# GitHub Actions for .NET Core NuGet packages

Last weekend I migrated the [Giraffe web framework](https://github.com/giraffe-fsharp/Giraffe) from [AppVeyor](https://www.appveyor.com) to [GitHub Actions](https://github.com/features/actions). It proved to be incredibly easy to do so despite me having some very specific requirements on how I wanted the final solution to work and that it should be flexible enough to apply to all my other projects too. Even though it was mostly a very straight forward job, there were a few things which I learned along the way which I thought would be worth sharing! 

Here's a quick summary of what I did, why I did it and most importantly how you can apply the same GitHub workflow to your own .NET Core NuGet project as well!

## Building a CI/CD pipeline for .NET Core packages

First, let's look at the requirements which I set out for my final CI/CD pipeline to meet. Each of these points has a specific purpose which I think is applicable to most .NET Core NuGet libraries and therefore explaining in more detail.

### Branch and pull request trigger

CI builds are the first formal check as part of the software development feedback loop which don't come from a developer's machine itself. They are reproducible and reliable feedback and arguably cheap to run in the cloud. As such CI builds should run as frequently as possible so that new errors can be flagged up as soon as they occur.

On this premise I decided that each commit, regardless if it happened on a `feature/*`, `hotfix/*` or other branch, should trigger a CI build. Pull requests should trigger a CI build as well. It's a great way of validating the changes of a PR before deciding whether to merge. As a matter of fact, it's highly recommended to enforce this rule through GitHub itself.

In GitHub, if you navigate to **Settings** and then **Branches** you can set up [branch protection rules](https://help.github.com/en/github/administering-a-repository/configuring-protected-branches) for your repository like this:

[![GitHub Branch Protection Rules](https://storage.googleapis.com/dusted-codes/images/blog-posts/2020-06-28/github-branch-protection-rules.png)](https://storage.googleapis.com/dusted-codes/images/blog-posts/2020-06-28/github-branch-protection-rules.png)

Note that the options in the list get automatically updated whenever a CI pipeline is executed and therefore might not show up before the first workflow has run. 

We can configure a GitHub Action to trigger builds for commits and pull requests against all branches by providing the `push` and `pull_request` option and leaving the branch definitions blank:

```yaml
on:
  push:
  pull_request:
```   

### Test on Linux, macOS and Windows

.NET Core is cross platform compatible and so it's not a surprise that a NuGet library is expected work on Linux, macOS and Windows as well.

Running a CI job against multiple OS versions can be configured via a build matrix:

```yaml
jobs:
  build:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ ubuntu-latest, windows-latest, macos-latest ]
``` 

In this example I've named the &quot;build&quot; job `build`, which is an arbitrary value and can be changed to anything a user wants.

### Create build artifacts

A build artifact is downloadable output which can be created and collected on each CI run. It can be anything from a single file to an entire folder full of binaries. In the case of a .NET Core NuGet library it is a very useful feature to create a super early version of a NuGet package as soon as a build has finished: 

[![GitHub Action Build Artifacts](https://storage.googleapis.com/dusted-codes/images/blog-posts/2020-06-28/github-build-artifacts.png)](https://storage.googleapis.com/dusted-codes/images/blog-posts/2020-06-28/github-build-artifacts.png)

In combination with pull request triggers this is a super handy way of giving OSS contributors and OSS maintainers an easy way of downloading and testing a NuGet package as part of a PR.

It is also a nice way of letting users download and consume a &quot;super early semi official&quot; NuGet package which came from the project's official CI pipeline when someone is in absolute desperate need of applying a fix before an official release or pre-release has been created.

In GitHub a NuGet artifact can be easily created by first running the `dotnet pack` command as part of an earlier build step and subsequently using the `upload-artifact@v2` action to upload the newly created `*.nupkg` as an artifact:

```yaml
jobs:
  build:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ ubuntu-latest, windows-latest, macos-latest ]
    steps:
      ...
      ...
      - name: Pack
        if: matrix.os == 'ubuntu-latest'
        run: dotnet pack -v normal -c Release --no-restore --include-symbols --include-source -p:PackageVersion=$GITHUB_RUN_ID src/$PROJECT_NAME/$PROJECT_NAME.*proj
      - name: Upload Artifact
        if: matrix.os == 'ubuntu-latest'
        uses: actions/upload-artifact@v2
        with:
          name: nupkg
          path: ./src/${{ env.PROJECT_NAME }}/bin/Release/*.nupkg
```  

In the example above I'm using the pre-defined `GITHUB_RUN_ID` environment variable to specify the NuGet package version and a custom defined environment variable called `PROJECT_NAME` to specify which .NET Core project to pack and publish as an artifact. This has the benefit that the same GitHub workflow definition can be used across multiple projects with very minimal initial setup.

One might have also noticed that I used a wildcard definition for the project file extension (`.*proj`) which has the additional benefit that the `dotnet pack` command will work for all types of .NET Core projects, which are `.vbproj`, `.csproj` and `.fsproj`.

Lastly I had to use the version 2 (`@v2`) of the `upload-artifact` action in order to use wildcard definitions in the artifact's `path` specification. If you run into a &quot;missing file&quot; error when trying to upload an artifact then make sure that you're using the latest version of this action.

On another note, the `if: matrix.os == 'ubuntu-latest'` condition as part of the `Pack` and `Upload Artifact` steps has no special purpose except limiting the artifact upload to a single run from the previously defined build matrix. A single artifact upload is sufficient and I simply chose `ubuntu-latest` because Ubuntu happens to be the fastest executing environment and therefore helps to keep the overall build time as low as possible. Windows workers seem to take generally longer than macOS or Ubuntu. 

### Push nightly releases to GitHub packages

You might have heard of the term &quot;Nightly Build&quot; before. A nightly build (or what I like to call a bleeding edge pre-release build) is a proper (formal) deployment of a build artifact to a place which makes general consumption almost as intuitive as an official release.

In the context of a NuGet package a &quot;nightly release&quot; is a NuGet library which normally gets pushed to a public NuGet feed which is just like the official [NuGet Gallery](https://www.nuget.org), but not the gallery itself. This is a common pattern among .NET Core libraries because developers can configure more than one NuGet feed in their project via a `NuGet.config` file (see the [NuGet.config reference](https://docs.microsoft.com/en-us/nuget/reference/nuget-config-file) for more information) and therefore consume a nightly build package just the same way as an official release. Most commonly I've seen self hosted [ProGet](https://inedo.com/proget) feeds or cloud hosted [MyGet](https://www.myget.org) feeds to distribute &quot;nightly builds&quot; alongside the official NuGet gallery. However, GitHub's relatively new [Packages](https://github.com/features/packages) feature makes an attractive alternative.

Setting up a nightly build pipeline to [GitHub packages](https://github.com/features/packages) is fairly easy:

```yaml
jobs:
  build:
    ...
    ...
  prerelease:
    needs: build
    if: github.ref == 'refs/heads/develop'
    runs-on: ubuntu-latest
    steps:
      - name: Download Artifact
        uses: actions/download-artifact@v1
        with:
          name: nupkg
      - name: Push to GitHub Feed
        run: |
          for f in ./nupkg/*.nupkg
          do
            curl -vX PUT -u "$GITHUB_USER:$GITHUB_TOKEN" -F package=@$f $GITHUB_FEED
          done
```

Unlike build artifacts nightly releases are not something which one would want to happen on every CI run. It makes sense to limit the creation of a pre-release/nightly deployment to a trigger which is at least one step closer to an official release (and not just a casual git commit or a random pull request). If one uses [Git flow](https://nvie.com/posts/a-successful-git-branching-model/) or another similar branching strategy then the `develop` branch is a natural gate keeper for a nightly release:

```yaml
if: github.ref == 'refs/heads/develop'
```

Anything which gets pushed into the `develop` branch is per definition on the road map for the next official release and hence a good trigger for a nightly build.

I've created a complete separate job called `prerelease` for this purpose alone. Just like the `build` job before, this name is completely random and can be changed to something entirely else. In addition the `prerelease` job should only execute after a successful `build` run:

```yaml
needs: build
```

If I hadn't specified this then GitHub would try to run multiple jobs in parallel which is not desired in this case.

The following two `steps` are fairly self explanatory:

```yaml
steps:
  - name: Download Artifact
    uses: actions/download-artifact@v1
    with:
      name: nupkg
  - name: Push to GitHub Feed
    run: |
      for f in ./nupkg/*.nupkg
      do
        curl -vX PUT -u "$GITHUB_USER:$GITHUB_TOKEN" -F package=@$f $GITHUB_FEED
      done
```

First I'm using the `download-artifact@v1` action to obtain the artifact which has been uploaded under the name `nupkg`. Later I use `curl` to make a HTTP PUT request directly to GitHub's HTTP API to upload the downloaded `*.nupkg` package to the specified feed.

The name of the feed is determined through the `GITHUB_FEED` environment variable (more on this later). The `GITHUB_TOKEN` is a pre-defined environment variable which every GitHub Action has automatically created for.

#### GitHub packages issue with NuGet

Now one might wonder why I used `curl` to directly interact with GitHub's HTTP API if I could have used `dotnet nuget push` or `nuget push` instead? The short answer is because both of these CLI commands don't work with GitHub's package feeds today.

*They only work if the worker image is set to `windows-latest`, however, because the start-up time of a Windows worker is significantly longer than `ubuntu-latest` I rather trade a little bit of `curl` &quot;complexity&quot; for an overall faster CD pipeline. It is a personal choice and a trade off which made sense in this particular case for me.*

### GitHub release trigger for official NuGet release

Since GitHub has the concept of a release, which uses git tags as an underlying release strategy, it's a nice way of triggering an official NuGet release:

```yaml
on:
  push:
  pull_request:
  release:
    types:
      - published
```

In addition to the previously defined triggers I've added `release` of type `published` as an extra mechanism to kick off a build. A GitHub release can have multiple trigger types such as a draft (e.g. `created`) or an edit (`edited`), a delete (`deleted`) and more. If I want to limit the deployment to an actual release it needs specifying `published`.

### Drive NuGet version from Git Tags

```
  deploy:
    needs: build
    if: github.event_name == 'release'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Setup .NET Core
        uses: actions/setup-dotnet@v1
        with:
          dotnet-version: 3.1.301
      - name: Create Release NuGet package
        run: |
          arrTag=(${GITHUB_REF//\// })
          VERSION="${arrTag[2]}"
          echo Version: $VERSION
          VERSION="${VERSION//v}"
          echo Clean Version: $VERSION
          dotnet pack -v normal -c Release --include-symbols --include-source -p:PackageVersion=$VERSION -o nupkg src/$PROJECT_NAME/$PROJECT_NAME.*proj
      - name: Push to GitHub Feed
        run: |
          for f in ./nupkg/*.nupkg
          do
            curl -vX PUT -u "$GITHUB_USER:$GITHUB_TOKEN" -F package=@$f $GITHUB_FEED
          done
      - name: Push to NuGet Feed
        run: dotnet nuget push ./nupkg/*.nupkg --source $NUGET_FEED --skip-duplicate --api-key $NUGET_KEY
```

### Speed

Speed is paramount in a good CI/CD pipeline. The longer a single run takes, the more likely it is that multiple triggers will result in long queues of individual CI runs stacking up and therefore preventing developers from getting a fast feedback loop.

There's a few things which can be done to speed up a .NET Core NuGet pipeline, some of them are...

#### Ubuntu over Windows

All jobs use the `ubuntu-latest` worker image except the first `build` job which uses a build matrix of three different OS versions to build and test against all major environments. Ubuntu workers start faster and hence should be preferred over Windows images.

#### Avoid redundant dotnet restores

The `build` job has been optimised to no repeat the `dotnet restore` step unnecessarily by making use of the `--no-restore` and `--no-build` flags where possible.

#### Avoid redundant NuGet caching

Setting the environment variable `DOTNET_SKIP_FIRST_TIME_EXPERIENCE` to `true` means that we can prevent the .NET CLI from wasting time on redundant package caching.

#### Turn off telemetry

Maybe not a huge gain, but surely turning off the .NET telemetry by setting the `DOTNET_CLI_TELEMETRY_OPTOUT` environment variable to `true` will shave off yet another few (milli)seconds.

#### Avoid pulling in extra dependencies

Not having to install extra utilities on a worker image means that the CI run doesn't have to waste extra time setting up additional tools. For example, instead of installing the standalone NuGet CLI one can use `dotnet nuget` which comes out of the box when .NET Core is set up as a dependency. Another example is to use `curl` when it already exists instead of pulling in another HTTP tool for little benefits.

#### Bash over PowerShell

Running `bash` scripts is significantly faster than running PowerShell (`pwsh`), because PowerShell takes longer to load. Luckily all script blocks are set to `bash` by default unless specified otherwise. Try to avoid PowerShell scripts if not necessarily required (e.g. using a little bit more `bash` instead of fancier `pwsh` for establishing the NuGet release version).

Overall these micro improvements mean that an incoming pull request takes approximately two minutes to successfully build against the entire build matrix and produce a NuGet build artifact:

[![GitHub Action Build time for Giraffe](https://storage.googleapis.com/dusted-codes/images/blog-posts/2020-06-28/github-action-build-time.png)](https://storage.googleapis.com/dusted-codes/images/blog-posts/2020-06-28/github-action-build-time.png)

A release build, which creates an additional NuGet package which gets pushed to GitHub packages and the official NuGet gallery takes approximately three minutes in total.

## The End Result

###### build.yml

```yaml
name: .NET Core
on:
  push:
  pull_request:
  release:
    types:
      - published
env:
  # Stop wasting time caching packages
  DOTNET_SKIP_FIRST_TIME_EXPERIENCE: true
  # Disable sending usage data to Microsoft
  DOTNET_CLI_TELEMETRY_OPTOUT: true
  # Project name to pack and publish
  PROJECT_NAME: Giraffe
  # GitHub Packages Feed settings
  GITHUB_FEED: https://nuget.pkg.github.com/giraffe-fsharp/
  GITHUB_USER: dustinmoris
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  # Official NuGet Feed settings
  NUGET_FEED: https://api.nuget.org/v3/index.json
  NUGET_KEY: ${{ secrets.NUGET_KEY }}
jobs:
  build:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ ubuntu-latest, windows-latest, macos-latest ]
    steps:
      - name: Checkout
        uses: actions/checkout@v2
      - name: Setup .NET Core
        uses: actions/setup-dotnet@v1
        with:
          dotnet-version: 3.1.301
      - name: Restore
        run: dotnet restore
      - name: Build
        run: dotnet build -c Release --no-restore
      - name: Test
        run: dotnet test -c Release
      - name: Pack
        if: matrix.os == 'ubuntu-latest'
        run: dotnet pack -v normal -c Release --no-restore --include-symbols --include-source -p:PackageVersion=$GITHUB_RUN_ID src/$PROJECT_NAME/$PROJECT_NAME.*proj
      - name: Upload Artifact
        if: matrix.os == 'ubuntu-latest'
        uses: actions/upload-artifact@v2
        with:
          name: nupkg
          path: ./src/${{ env.PROJECT_NAME }}/bin/Release/*.nupkg
  prerelease:
    needs: build
    if: github.ref == 'refs/heads/develop'
    runs-on: ubuntu-latest
    steps:
      - name: Download Artifact
        uses: actions/download-artifact@v1
        with:
          name: nupkg
      - name: Push to GitHub Feed
        run: |
          for f in ./nupkg/*.nupkg
          do
            curl -vX PUT -u "$GITHUB_USER:$GITHUB_TOKEN" -F package=@$f $GITHUB_FEED
          done
  deploy:
    needs: build
    if: github.event_name == 'release'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Setup .NET Core
        uses: actions/setup-dotnet@v1
        with:
          dotnet-version: 3.1.301
      - name: Create Release NuGet package
        run: |
          arrTag=(${GITHUB_REF//\// })
          VERSION="${arrTag[2]}"
          echo Version: $VERSION
          VERSION="${VERSION//v}"
          echo Clean Version: $VERSION
          dotnet pack -v normal -c Release --include-symbols --include-source -p:PackageVersion=$VERSION -o nupkg src/$PROJECT_NAME/$PROJECT_NAME.*proj
      - name: Push to GitHub Feed
        run: |
          for f in ./nupkg/*.nupkg
          do
            curl -vX PUT -u "$GITHUB_USER:$GITHUB_TOKEN" -F package=@$f $GITHUB_FEED
          done
      - name: Push to NuGet Feed
        run: dotnet nuget push ./nupkg/*.nupkg --source $NUGET_FEED --skip-duplicate --api-key $NUGET_KEY
```

