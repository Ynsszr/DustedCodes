<!--
    Tags: devops github dotnet-core ci-cd nuget
-->

# GitHub Actions for .NET Core NuGet packages

Last weekend I migrated the [Giraffe web framework](https://github.com/giraffe-fsharp/Giraffe) from [AppVeyor](https://www.appveyor.com) to [GitHub Actions](https://github.com/features/actions). It proved to be incredibly easy to do so despite me having some very specific requirements on how I wanted the final solution to work and that it should be flexible enough to apply to all my other projects too. Even though it was mostly a very straight forward job, there were a few things which I learned along the way which I thought would be worth going through! 

Here's a quick summary of what I did, why I did it and most importantly how you can apply the same GitHub workflow to your own .NET Core NuGet project as well!

## Building a CI/CD pipeline for .NET Core packages

First, let's look at the requirements which I set out for my final CI/CD pipeline to meet. Each of these points has a specific purpose which I think is applicable to most .NET Core NuGet libraries and therefore worth explaining.

### Branch and pull request trigger

CI builds are the first formal check as part of the software development feedback loop which don't come from a developer's machine itself. They are reproducible and reliable feedback and arguably cheap to run in the cloud. As such CI builds should run as frequently as possible so that new errors can be flagged up as soon as they occur.

On this premise I decided that each commit, regardless if it happened on a `feature/*`, `hotfix/*` or other branch, should trigger a CI build. Pull requests should trigger a CI build as well. It's a great way of validating the changes of a PR before deciding whether to merge. As a matter of fact, it's highly recommended to enforce this rule through GitHub itself.

In GitHub, if you navigate to **Settings** and then **Branches** you can set up [branch protection rules](https://help.github.com/en/github/administering-a-repository/configuring-protected-branches) for your repository like this:

[![GitHub Branch Protection Rules](https://storage.googleapis.com/dusted-codes/images/blog-posts/2020-06-28/github-branch-protection-rules.png)](https://storage.googleapis.com/dusted-codes/images/blog-posts/2020-06-28/github-branch-protection-rules.png)

Note that the options in the list get automatically updated whenever a CI pipeline is executed and therefore might not show up before the first workflow has run. 

We can configure a GitHub Action to trigger builds for commits and pull requests against all branches by providing the `push` and `pull_request` option and leaving the branch definitions blank:

```yaml
on:
  push:
  pull_request:
```   

### Test on Linux, macOS and Windows

.NET Core is cross platform compatible so it's not a surprise that a NuGet library is expected work on Linux, macOS and Windows as well.

Running a CI job against multiple OS versions can be configured via a build matrix:

```yaml
jobs:
  build:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ ubuntu-latest, windows-latest, macos-latest ]
``` 

In this example I've named the &quot;build&quot; job `build`, which is an arbitrary value and can be changed to anything a user wants.

### Create build artifacts

A build artifact is downloadable output which can be created and collected on each CI run. It can be anything from a single file to an entire folder full of binaries. In the case of a .NET Core NuGet library it is a very useful feature to create a super early version of a NuGet package as soon as a build has finished: 

[![GitHub Action Build Artifacts](https://storage.googleapis.com/dusted-codes/images/blog-posts/2020-06-28/github-build-artifacts.png)](https://storage.googleapis.com/dusted-codes/images/blog-posts/2020-06-28/github-build-artifacts.png)

In combination with pull request triggers this is a super handy way of giving OSS contributors and OSS maintainers an easy way of downloading and testing a NuGet package as part of a PR.

It is also a nice way of letting users download and consume a &quot;super early semi official&quot; NuGet package which came from the project's official CI pipeline when someone is in absolutely desperate need to apply a fix before an official release or pre-release has been created.

In GitHub a .NET Core build artifact can be easily accomplished by first running the `dotnet pack` command as part of an earlier build step and subsequently using the `upload-artifact@v2` action to upload the produced `*.nupkg`:

```yaml
jobs:
  build:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ ubuntu-latest, windows-latest, macos-latest ]
    steps:
      ...
      ...
      - name: Pack
        if: matrix.os == 'ubuntu-latest'
        run: dotnet pack -v normal -c Release --no-restore --include-symbols --include-source -p:PackageVersion=$GITHUB_RUN_ID src/$PROJECT_NAME/$PROJECT_NAME.*proj
      - name: Upload Artifact
        if: matrix.os == 'ubuntu-latest'
        uses: actions/upload-artifact@v2
        with:
          name: nupkg
          path: ./src/${{ env.PROJECT_NAME }}/bin/Release/*.nupkg
```  

In the example above I'm using the pre-defined `GITHUB_RUN_ID` environment variable to specify the NuGet version and a custom defined environment variable called `PROJECT_NAME` to specify which project to pack and publish as an artifact. This has the benefit that the same GitHub workflow can be used across multiple projects with very minimal setup.

A close observer might have also noticed that I used a wildcard definition for the project file extension (`.*proj`), which has the additional benefit that the `dotnet pack` command will work for all kinds of .NET Core projects, which are `.vbproj`, `.csproj` and `.fsproj`.

Lastly I had to use the version 2 (`@v2`) of the `upload-artifact` action in order to use wildcard definitions in the artifact's `path` specification. If you run into a missing file error when trying to upload an artifact then make sure you're using the latest version of this action.

On another note, the `if: matrix.os == 'ubuntu-latest'` condition which has been applied to the `Pack` and `Upload Artifact` step has no special meaning except that it is sufficient to upload the artifact from only one of the three runs from the previously defined build matrix. I simply chose `ubuntu-latest` because it happens to be the fastest executing environment and therefore helps to keep the overall build time as little as possible (Windows workers seem to take generally longer than `macOS` and `Ubuntu`). 

### Push nightly releases to GitHub packages

You might have heard of the term &quot;Nightly Build&quot; before. A nightly build (or what I like to call a bleeding edge pre-release build) is a proper (formal) deployment of a build artifact to a place which makes general consumption almost as intuitive as an official release at a later stage.

In the context of a NuGet package a &quot;nightly release&quot; is a NuGet library which normally gets pushed to a public NuGet feed which is just like the official [NuGet Gallery](https://www.nuget.org), but not the gallery itself. This is a common pattern for .NET Core libraries because developers can configure more than one NuGet feed in their project via a `NuGet.config` file (see the [nuget.config reference](https://docs.microsoft.com/en-us/nuget/reference/nuget-config-file) for more information) and therefore consume a nightly build package just the same way as an official release. Most commonly I've seen self hosted [ProGet](https://inedo.com/proget) feeds or cloud hosted [MyGet](https://www.myget.org) feeds to distribute &quot;nightly builds&quot; alongside the official NuGet gallery. However, GitHub's relatively new [Packages](https://github.com/features/packages) feature makes an attractive alternative.

Setting up a nightly build pipeline to [GitHub packages](https://github.com/features/packages) is fairly easy:

```yaml
jobs:
  build:
    ...
    ...
  prerelease:
    needs: build
    if: github.ref == 'refs/heads/develop'
    runs-on: ubuntu-latest
    steps:
      - name: Download Artifact
        uses: actions/download-artifact@v1
        with:
          name: nupkg
      - name: Push to GitHub Feed
        run: |
          for f in ./nupkg/*.nupkg
          do
            curl -vX PUT -u "$GITHUB_USER:$GITHUB_TOKEN" -F package=@$f $GITHUB_FEED
          done
```

Nightly releases are not something which you want to create on every CI run (unlike build artifacts). It makes sense to limit the creation of a pre-release/nightly deployment to a trigger which is at least one step closer to an official release (not just a casual git commit or a random pull request). If you use [Git flow](https://nvie.com/posts/a-successful-git-branching-model/) or another similar branching strategy then the `develop` branch is a natural gate keeper of a nightly release:

```
if: github.ref == 'refs/heads/develop'
```

Anything which gets pushed into the `develop` branch is per definition on the road map for the next official release and hence a good trigger for a nightly build.

I've created a complete separate job called `prerelease` for this purpose alone. The name is completely arbitrary and can be swapped for anything else instead.

Because the `prerelease` job is a separate job to `build` and I only want to run it after `build` completed successfully, I had to explicitly disable the parallel run:

```
needs: build
```

Note that I had put `build` here because this was the chosen name for the initial job, however just like `prerelease` this can be changed to any custom name.

The two steps are fairly self explanatory. First I'm using the `download-artifact@v1` action to obtain the artifact which has been uploaded under the name `nupkg` and later I make a HTTP PUT request to GitHub's HTTP API to upload the `*.nupkg` to the specified feed. The name of the feed is determined through the `GITHUB_FEED` environment variable, which is set up at an earlier stage (more on this later). The `GITHUB_TOKEN` is a pre-defined environment variable which every GitHub CI run has access to and doesn't need manual set up.

#### GitHub packages issue with NuGet

Now one might wonder why I used `curl` to directly interact with GitHub's HTTP API if I could have used `dotnet nuget push` or `nuget push` instead. The short answer is because both of these CLI commands currently don't work with GitHub package feeds as easy as they should. They do work as expected if the worker image is `windows-latest`, but because the start-up time of a Windows worker is significantly longer than `ubuntu-latest` I rather use `curl` which also happens to be extremely fast than the convenience of `dotnet nuget push`. It is a personal choice, where I rank build speed higher than the minimal extra complexity of running a bare bones `curl` command.

### GitHub release trigger for official NuGet release

Since GitHub has the concept of a release, which uses git tags as an underlying release strategy, it's a nice way of triggering an official NuGet release:

```yaml
on:
  push:
  pull_request:
  release:
    types:
      - published
```

In addition to the previously defined triggers I've added `release` of type `published` as an extra mechanism to kick off a build. A GitHub release can have multiple trigger types such as a draft (e.g. `created`) or an edit (`edited`), a delete (`deleted`) and more. If I want to limit the deployment to an actual release it needs specifying `published`.

### Drive NuGet version from Git Tags

```
  deploy:
    needs: build
    if: github.event_name == 'release'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Setup .NET Core
        uses: actions/setup-dotnet@v1
        with:
          dotnet-version: 3.1.301
      - name: Create Release NuGet package
        run: |
          arrTag=(${GITHUB_REF//\// })
          VERSION="${arrTag[2]}"
          echo Version: $VERSION
          VERSION="${VERSION//v}"
          echo Clean Version: $VERSION
          dotnet pack -v normal -c Release --include-symbols --include-source -p:PackageVersion=$VERSION -o nupkg src/$PROJECT_NAME/$PROJECT_NAME.*proj
      - name: Push to GitHub Feed
        run: |
          for f in ./nupkg/*.nupkg
          do
            curl -vX PUT -u "$GITHUB_USER:$GITHUB_TOKEN" -F package=@$f $GITHUB_FEED
          done
      - name: Push to NuGet Feed
        run: dotnet nuget push ./nupkg/*.nupkg --source $NUGET_FEED --skip-duplicate --api-key $NUGET_KEY
```

### Speed

...


## The End Result

In order to get started with [GitHub Actions](https://github.com/features/actions) one has to create a new folder called `.github` inside a project's root folder and then within that folder create another folder called `workflows`.

The `workflows` folder can contain one or many `.yml` files which GitHub will automatically parse and process in order to trigger a CI/CD run. There's no extra settings, toggles or other shenanigans required. If there's a `.yml` file present then GitHub will run the action, otherwise it won't, simple as that.

In my case I want the CI/CD run to start whenever there was a new Git push, pull request or when a new GitHub release has been published:

###### build.yml

```yaml
name: .NET Core
on:
  push:
  pull_request:
  release:
    types:
      - published
env:
  # Stop wasting time caching packages
  DOTNET_SKIP_FIRST_TIME_EXPERIENCE: true
  # Disable sending usage data to Microsoft
  DOTNET_CLI_TELEMETRY_OPTOUT: true
  # Project name to pack and publish
  PROJECT_NAME: Giraffe
  # GitHub Packages Feed settings
  GITHUB_FEED: https://nuget.pkg.github.com/giraffe-fsharp/
  GITHUB_USER: dustinmoris
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  # Official NuGet Feed settings
  NUGET_FEED: https://api.nuget.org/v3/index.json
  NUGET_KEY: ${{ secrets.NUGET_KEY }}
jobs:
  build:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ ubuntu-latest, windows-latest, macos-latest ]
    steps:
      - name: Checkout
        uses: actions/checkout@v2
      - name: Setup .NET Core
        uses: actions/setup-dotnet@v1
        with:
          dotnet-version: 3.1.301
      - name: Restore
        run: dotnet restore
      - name: Build
        run: dotnet build -c Release --no-restore
      - name: Test
        run: dotnet test -c Release
      - name: Pack
        if: matrix.os == 'ubuntu-latest'
        run: dotnet pack -v normal -c Release --no-restore --include-symbols --include-source -p:PackageVersion=$GITHUB_RUN_ID src/$PROJECT_NAME/$PROJECT_NAME.*proj
      - name: Upload Artifact
        if: matrix.os == 'ubuntu-latest'
        uses: actions/upload-artifact@v2
        with:
          name: nupkg
          path: ./src/${{ env.PROJECT_NAME }}/bin/Release/*.nupkg
  prerelease:
    needs: build
    if: github.ref == 'refs/heads/develop'
    runs-on: ubuntu-latest
    steps:
      - name: Download Artifact
        uses: actions/download-artifact@v1
        with:
          name: nupkg
      - name: Push to GitHub Feed
        run: |
          for f in ./nupkg/*.nupkg
          do
            curl -vX PUT -u "$GITHUB_USER:$GITHUB_TOKEN" -F package=@$f $GITHUB_FEED
          done
  deploy:
    needs: build
    if: github.event_name == 'release'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Setup .NET Core
        uses: actions/setup-dotnet@v1
        with:
          dotnet-version: 3.1.301
      - name: Create Release NuGet package
        run: |
          arrTag=(${GITHUB_REF//\// })
          VERSION="${arrTag[2]}"
          echo Version: $VERSION
          VERSION="${VERSION//v}"
          echo Clean Version: $VERSION
          dotnet pack -v normal -c Release --include-symbols --include-source -p:PackageVersion=$VERSION -o nupkg src/$PROJECT_NAME/$PROJECT_NAME.*proj
      - name: Push to GitHub Feed
        run: |
          for f in ./nupkg/*.nupkg
          do
            curl -vX PUT -u "$GITHUB_USER:$GITHUB_TOKEN" -F package=@$f $GITHUB_FEED
          done
      - name: Push to NuGet Feed
        run: dotnet nuget push ./nupkg/*.nupkg --source $NUGET_FEED --skip-duplicate --api-key $NUGET_KEY
```

